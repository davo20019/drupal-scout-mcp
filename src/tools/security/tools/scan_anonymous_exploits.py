"""
Anonymous exploit detection scanner.

Part of Drupal Scout MCP security scanning suite.
"""

import logging
from pathlib import Path
from typing import Optional, Dict, List

from src.core.config import ensure_indexed
from server import mcp

logger = logging.getLogger(__name__)


# Import shared components  # noqa: E402
from src.tools.security.patterns import (  # noqa: E402
    XSS_PATTERNS,
    SQL_INJECTION_PATTERNS,
    COMMAND_INJECTION_PATTERNS,
    PATH_TRAVERSAL_PATTERNS,
)
from src.tools.security.ast_analysis import (  # noqa: E402
    _get_php_files,
    _scan_file_for_patterns,
    _format_findings,
)
from src.tools.code_analysis import _find_module_path  # noqa: E402

# Additional imports for route parsing
from src.tools.security.models import SecurityFinding  # noqa: E402


# ============================================================================
# HELPER FUNCTIONS FOR ANONYMOUS EXPLOIT ANALYSIS
# ============================================================================

# ============================================================================


def _parse_routing_file(routing_file: Path) -> Dict[str, Dict]:
    """
    Parse a Drupal routing.yml file to extract route definitions.

    Returns:
        Dict mapping route names to their access requirements
    """
    import yaml

    try:
        with open(routing_file, "r") as f:
            routes = yaml.safe_load(f) or {}

        route_info = {}
        for route_name, route_config in routes.items():
            if not isinstance(route_config, dict):
                continue

            # Extract access requirements
            requirements = route_config.get("requirements", {})

            # Determine if anonymous users can access
            is_anonymous_accessible = True
            access_level = "PUBLIC"

            if "_permission" in requirements:
                permission = requirements["_permission"]
                # Check if it's a restrictive permission
                if permission and permission not in ["access content"]:
                    is_anonymous_accessible = False
                    access_level = f"REQUIRES: {permission}"

            if "_role" in requirements:
                role = requirements["_role"]
                if "anonymous" not in role.lower():
                    is_anonymous_accessible = False
                    access_level = f"REQUIRES ROLE: {role}"

            if "_access" in requirements:
                if requirements["_access"] != "TRUE":
                    is_anonymous_accessible = False
                    access_level = f"CUSTOM ACCESS: {requirements['_access']}"

            # Extract controller/form info
            defaults = route_config.get("defaults", {})
            controller = defaults.get(
                "_controller", defaults.get("_form", defaults.get("_entity_form", "unknown"))
            )

            route_info[route_name] = {
                "anonymous_accessible": is_anonymous_accessible,
                "access_level": access_level,
                "controller": controller,
                "path": route_config.get("path", ""),
                "methods": route_config.get("methods", ["GET"]),
            }

        return route_info

    except Exception as e:
        logger.error(f"Error parsing routing file {routing_file}: {e}")
        return {}


def _map_findings_to_routes(
    module_dir: Path, findings: List[SecurityFinding]
) -> Dict[str, List[SecurityFinding]]:
    """
    Map security findings to their routes by matching controller/form classes.

    Returns:
        Dict mapping route names to list of findings in that route
    """
    # Find all routing files
    routing_files = list(module_dir.rglob("*.routing.yml"))

    # Parse all routes
    all_routes = {}
    for routing_file in routing_files:
        routes = _parse_routing_file(routing_file)
        all_routes.update(routes)

    # Map findings to routes
    route_findings = {}

    for finding in findings:
        # Extract class/controller name from file path
        # e.g., src/Controller/DeepChatApi.php -> DeepChatApi
        file_path = Path(finding.file)

        # Try to match with route controllers
        for route_name, route_info in all_routes.items():
            controller = route_info["controller"]

            # Check if finding file matches controller
            if file_path.stem in controller or controller.split("::")[0].endswith(file_path.stem):
                if route_name not in route_findings:
                    route_findings[route_name] = {"route_info": route_info, "findings": []}
                route_findings[route_name]["findings"].append(finding)

    return route_findings


@mcp.tool()
def scan_anonymous_exploits(
    module_name: str, module_path: Optional[str] = None, max_findings: int = 50
) -> str:
    """
    Identify security vulnerabilities that are exploitable by anonymous (unauthenticated) users.

    This tool combines security scanning with routing analysis to determine which
    vulnerabilities can be exploited remotely without authentication.

    Workflow:
    1. Runs security scans (XSS, SQL injection, command injection, path traversal)
    2. Parses routing.yml files to identify anonymous-accessible routes
    3. Maps vulnerabilities to routes
    4. Reports only vulnerabilities accessible to anonymous users

    This is critical for prioritizing security fixes - anonymous exploits are the
    highest priority as they can be exploited remotely without credentials.

    Args:
        module_name: Module machine name to scan
        module_path: Optional explicit module path override
        max_findings: Maximum findings to show (default: 50)

    Returns:
        Formatted report with anonymously exploitable vulnerabilities prioritized

    Examples:
        scan_anonymous_exploits("my_api_module")
        scan_anonymous_exploits("chatbot", max_findings=20)

    Use case:
        - Pre-deployment security checks
        - Identifying critical remote vulnerabilities
        - Prioritizing security fixes
        - Penetration testing preparation
    """
    ensure_indexed()

    module_dir = _find_module_path(module_name)
    if not module_dir:
        return f"âŒ ERROR: Module '{module_name}' not found. Use list_modules() to see available modules."

    output = []
    output.append(f"ðŸŽ¯ ANONYMOUS EXPLOIT SCAN: {module_name}")
    output.append("=" * 80)
    output.append("")
    output.append("Analyzing vulnerabilities exploitable by ANONYMOUS users...")
    output.append("(Remote exploitation without authentication)")
    output.append("")

    # Get PHP files
    php_files = _get_php_files(module_dir)

    if not php_files:
        return f"No PHP files found in module '{module_name}'"

    # Run security scans for exploitable vulnerability types
    all_findings = []

    # XSS - anonymously exploitable if in public routes
    for php_file in php_files:
        findings = _scan_file_for_patterns(php_file, XSS_PATTERNS, "xss")
        all_findings.extend(findings)

    # SQL injection - anonymously exploitable
    for php_file in php_files:
        findings = _scan_file_for_patterns(php_file, SQL_INJECTION_PATTERNS, "sql_injection")
        all_findings.extend(findings)

    # Command injection - anonymously exploitable
    for php_file in php_files:
        findings = _scan_file_for_patterns(
            php_file, COMMAND_INJECTION_PATTERNS, "command_injection"
        )
        all_findings.extend(findings)

    # Path traversal - anonymously exploitable
    for php_file in php_files:
        findings = _scan_file_for_patterns(php_file, PATH_TRAVERSAL_PATTERNS, "path_traversal")
        all_findings.extend(findings)

    # Filter to HIGH severity only (most critical for anonymous exploits)
    high_findings = [f for f in all_findings if f.severity == "high"]

    output.append(f"ðŸ“Š Found {len(high_findings)} HIGH severity vulnerabilities")
    output.append("")
    output.append("â”€" * 80)
    output.append("")

    # Parse routing files
    routing_files = list(module_dir.rglob("*.routing.yml"))

    if not routing_files:
        output.append("âš ï¸  WARNING: No routing files found!")
        output.append("   Cannot determine anonymous accessibility without routing definitions.")
        output.append("")
        output.append("Showing all HIGH severity findings (manual route review needed):")
        output.append("")
        output.append(
            _format_findings(high_findings, "HIGH Severity Vulnerabilities", max_findings)
        )
        return "\n".join(output)

    # Parse all routes
    output.append(f"ðŸ“ Analyzing {len(routing_files)} routing file(s)...")
    output.append("")

    all_routes = {}
    for routing_file in routing_files:
        routes = _parse_routing_file(routing_file)
        all_routes.update(routes)

    # Categorize routes
    anonymous_routes = {k: v for k, v in all_routes.items() if v["anonymous_accessible"]}
    protected_routes = {k: v for k, v in all_routes.items() if not v["anonymous_accessible"]}

    output.append(f"   â€¢ {len(anonymous_routes)} routes accessible to ANONYMOUS users")
    output.append(f"   â€¢ {len(protected_routes)} routes require authentication")
    output.append("")

    if not anonymous_routes:
        output.append("âœ… GOOD NEWS: No routes are accessible to anonymous users!")
        output.append("   All vulnerabilities require authentication to exploit.")
        output.append("")
        output.append(f"However, {len(high_findings)} HIGH severity issues still need fixing:")
        output.append(
            _format_findings(high_findings, "Authenticated Vulnerabilities", max_findings)
        )
        return "\n".join(output)

    # Map findings to routes
    route_findings_map = _map_findings_to_routes(module_dir, high_findings)

    # Identify anonymously exploitable findings
    anonymous_exploits = []

    for route_name, data in route_findings_map.items():
        if data["route_info"]["anonymous_accessible"]:
            for finding in data["findings"]:
                anonymous_exploits.append(
                    {"route": route_name, "route_info": data["route_info"], "finding": finding}
                )

    output.append("â”€" * 80)
    output.append("")

    if not anonymous_exploits:
        output.append("âœ… GOOD NEWS: No HIGH severity vulnerabilities in anonymous routes!")
        output.append("")
        output.append(
            f"Note: Module has {len(anonymous_routes)} anonymous routes, but no mapped HIGH severity issues."
        )
        output.append("")
        output.append("âš ï¸  However, this does NOT guarantee safety:")
        output.append("   â€¢ Vulnerabilities may exist in code called by controllers")
        output.append("   â€¢ Manual code review still recommended for anonymous routes")
        output.append("")
        output.append("Anonymous accessible routes to review:")
        for route_name, route_info in list(anonymous_routes.items())[:10]:
            output.append(f"   â€¢ {route_name}")
            output.append(f"     Path: {route_info['path']}")
            output.append(f"     Controller: {route_info['controller']}")
            output.append("")
    else:
        output.append(
            f"ðŸš¨ CRITICAL: {len(anonymous_exploits)} ANONYMOUSLY EXPLOITABLE VULNERABILITIES!"
        )
        output.append("")
        output.append("These can be exploited REMOTELY without authentication:")
        output.append("")

        shown = 0
        for exploit in anonymous_exploits[:max_findings]:
            finding = exploit["finding"]
            route_info = exploit["route_info"]

            output.append(f"âŒ {exploit['route']}")
            output.append(f"   Route: {route_info['path']} ({', '.join(route_info['methods'])})")
            output.append(f"   Access: {route_info['access_level']}")
            output.append(f"   Vulnerability: {finding.category.upper()} - {finding.description}")
            output.append(f"   File: {Path(finding.file).name}:{finding.line}")
            output.append(f"   Code: {finding.code[:80]}{'...' if len(finding.code) > 80 else ''}")
            output.append(f"   Fix: {finding.recommendation}")
            output.append("")
            shown += 1

        if len(anonymous_exploits) > max_findings:
            output.append(
                f"... {len(anonymous_exploits) - max_findings} more anonymous exploits not shown"
            )
            output.append("")

        output.append("â”€" * 80)
        output.append("")
        output.append("ðŸš¨ IMMEDIATE ACTION REQUIRED:")
        output.append("  1. These vulnerabilities are REMOTELY EXPLOITABLE")
        output.append("  2. Fix HIGH severity issues in anonymous routes FIRST")
        output.append("  3. Consider temporarily disabling anonymous access")
        output.append("  4. Review all anonymous routes for additional issues")
        output.append("")
        output.append("ðŸ“š RESOURCES:")
        output.append("  â€¢ https://www.drupal.org/docs/security-in-drupal/writing-secure-code")
        output.append("  â€¢ https://www.drupal.org/docs/drupal-apis/routing-system")

    return "\n".join(output)
